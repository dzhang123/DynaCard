package com.organization.dynacard;

import java.util.Collections;
import java.util.List;
import java.util.ArrayList;

import com.organization.dynacard.IDynaCard.CardParameters;
import com.organization.dynacard.IDynaCard.CardShape;

public class DynaCardFactory {
	
	public static CardShape getCardShape (List<CardParameters> values, double minimumAcceptableWeight) {
		
		List<Double> weights = new ArrayList<Double>();
		for (int i = 0; i < values.size(); i++) {
			weights.add(values.get(i).pumpWeight);
		}
		double maxWeight = Collections.max(weights);
		
		if (maxWeight < minimumAcceptableWeight)
			return CardShape.Flowing_Well;
		return NewCard(values).getShape();		
	}
	
	public static DynaCard NewCard(List<CardParameters> values) {
		List<Integer> pos = new ArrayList<Integer>();
		List<Double> xs = new ArrayList<Double>();
		List<Double> ys = new ArrayList<Double>();
		
		for (int i = 0; i < values.size(); i++) {
			pos.add(values.get(i).anglePositoin);
			xs.add(values.get(i).strokeDisplacement);
			ys.add(values.get(i).pumpWeight);
		}
		
		return NewCard(pos, xs, ys);
	}
	
	public static DynaCard NewCard(List<Integer> pos, List<Double> xs, List<Double> ys) {
		List<ICardEdge> edges = SplitIntoEdges(pos, xs, ys);
		
		return new DynaCard(edges.get(0), edges.get(1), edges.get(2), edges.get(3));
	}
	
	public static List<ICardEdge> SplitIntoEdges (List<Integer> pos, List<Double> xs, List<Double> ys) {
		// temperary
        List<int> pos = anglePositions.ToList();
        List<double> xs = strokeDisplacements.ToList();
        List<double> ys = pumpWeights.ToList();

        xs = Normalize(xs);
        ys = Normalize(ys);

        // Identify indices of the corners of the trapezoid
        List<double> direction_upper_right = new List<double>(), direction_lower_right = new List<double>();

        for (int i = 0; i < pos.Count; i++)
        {
            direction_upper_right.Add(xs[i] + 2 * ys[i]);
            direction_lower_right.Add(xs[i] - 2 * ys[i]);
        }

        double min = direction_upper_right.Min();
        int min_index = direction_upper_right.IndexOf(min);
        double max = direction_upper_right.Max();
        int max_index = direction_upper_right.IndexOf(max);

        // int lower_left_ind = min_element(direction_upper_right.begin(), direction_upper_right.end()) - direction_upper_right.begin();
        int lower_left_index = min_index;
        // int upper_right_ind = max_element(direction_upper_right.begin(), direction_upper_right.end()) - direction_upper_right.begin();
        int upper_right_index = max_index;

        min = direction_lower_right.Min();
        min_index = direction_lower_right.IndexOf(min);
        max = direction_lower_right.Max();
        max_index = direction_lower_right.IndexOf(max);

        // int upper_left_ind = min_element(direction_lower_right.begin(), direction_lower_right.end()) - direction_lower_right.begin();
        int upper_left_index = min_index;
        // int lower_right_ind = max_element(direction_lower_right.begin(), direction_lower_right.end()) - direction_lower_right.begin();
        int lower_right_ind = max_index;

        // Create edges based on those corners
        CardEdge left = new CardEdge { Name = "left", Side = Sides.Left, Points = new List<(double x, double y)>()},
                top = new CardEdge { Name = "top", Side = Sides.Top, Points = new List<(double x, double y)>() },
                right = new CardEdge { Name = "right", Side = Sides.Right, Points = new List<(double x, double y)>()},
                bottom = new CardEdge { Name = "bottom", Side = Sides.Bottom, Points = new List<(double x, double y)>()};

        // Traveling index
        int index = lower_left_index;
        max_index = pos.Count;
        while (index != upper_left_index)
        {
            left.AddPoint(xs[index], ys[index]);
            index = IncrementWithRollOver(index, max_index);
        }
        while (index != upper_right_index)
        {
            top.AddPoint(xs[index], ys[index]);
            index = IncrementWithRollOver(index, max_index);
        }
        while (index != lower_right_ind)
        {
            right.AddPoint(xs[index], ys[index]);
            index = IncrementWithRollOver(index, max_index);
        }
        while (index != lower_left_index)
        {
            bottom.AddPoint(xs[index], ys[index]);
            index = IncrementWithRollOver(index, max_index);
        }

        left.Fit();
        top.Fit();
        right.Fit();
        bottom.Fit();

        return (left, top, right, bottom);
    }

    public static int IncrementWithRollOver (int i, int max) {
        i++;
        if (i == max)
            i = 0;
        return i;
    }
	
    public static List<Double> Normalize(List<Double> values) 
    {
    	double max = Collections.max(values);
    	double min = Collections.min(values);
    	
    	List<Double> normalized = new ArrayList<Double>();
    	for (Double d: values) {
    		normalized.add((d - min) / (max - min));
    	}
    }
}
